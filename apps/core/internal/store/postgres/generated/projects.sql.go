// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: projects.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const activateProject = `-- name: ActivateProject :one
UPDATE projects
SET status = 'active', updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, user_id, repo_id, repo_name, repo_full_name, repo_url, repo_branch, status, env_variables, deployment_status, domain, port, created_at, updated_at
`

func (q *Queries) ActivateProject(ctx context.Context, id string) (Project, error) {
	row := q.db.QueryRow(ctx, activateProject, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.RepoID,
		&i.RepoName,
		&i.RepoFullName,
		&i.RepoUrl,
		&i.RepoBranch,
		&i.Status,
		&i.EnvVariables,
		&i.DeploymentStatus,
		&i.Domain,
		&i.Port,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const archiveProject = `-- name: ArchiveProject :one
UPDATE projects
SET status = 'archived', updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, user_id, repo_id, repo_name, repo_full_name, repo_url, repo_branch, status, env_variables, deployment_status, domain, port, created_at, updated_at
`

func (q *Queries) ArchiveProject(ctx context.Context, id string) (Project, error) {
	row := q.db.QueryRow(ctx, archiveProject, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.RepoID,
		&i.RepoName,
		&i.RepoFullName,
		&i.RepoUrl,
		&i.RepoBranch,
		&i.Status,
		&i.EnvVariables,
		&i.DeploymentStatus,
		&i.Domain,
		&i.Port,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countProjects = `-- name: CountProjects :one
SELECT COUNT(*) FROM projects
`

func (q *Queries) CountProjects(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countProjects)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProjectsByStatus = `-- name: CountProjectsByStatus :one
SELECT COUNT(*) FROM projects WHERE status = $1
`

func (q *Queries) CountProjectsByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRow(ctx, countProjectsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProjectsByUserID = `-- name: CountProjectsByUserID :one
SELECT COUNT(*) FROM projects WHERE user_id = $1
`

func (q *Queries) CountProjectsByUserID(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countProjectsByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProject = `-- name: CreateProject :one
INSERT INTO projects (name, user_id, repo_id, repo_name, repo_full_name, repo_url, repo_branch, status, env_variables, deployment_status, domain, port)
VALUES ($1, $2, $3, $4, $5, $6, $7, 'active', $8, 'pending', $9, $10)
RETURNING id, name, user_id, repo_id, repo_name, repo_full_name, repo_url, repo_branch, status, env_variables, deployment_status, domain, port, created_at, updated_at
`

type CreateProjectParams struct {
	Name         string      `json:"name"`
	UserID       string      `json:"user_id"`
	RepoID       int64       `json:"repo_id"`
	RepoName     string      `json:"repo_name"`
	RepoFullName string      `json:"repo_full_name"`
	RepoUrl      string      `json:"repo_url"`
	RepoBranch   string      `json:"repo_branch"`
	EnvVariables []byte      `json:"env_variables"`
	Domain       pgtype.Text `json:"domain"`
	Port         pgtype.Int4 `json:"port"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, createProject,
		arg.Name,
		arg.UserID,
		arg.RepoID,
		arg.RepoName,
		arg.RepoFullName,
		arg.RepoUrl,
		arg.RepoBranch,
		arg.EnvVariables,
		arg.Domain,
		arg.Port,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.RepoID,
		&i.RepoName,
		&i.RepoFullName,
		&i.RepoUrl,
		&i.RepoBranch,
		&i.Status,
		&i.EnvVariables,
		&i.DeploymentStatus,
		&i.Domain,
		&i.Port,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects
WHERE id = $1
`

func (q *Queries) DeleteProject(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteProject, id)
	return err
}

const deleteProjectsByUserID = `-- name: DeleteProjectsByUserID :exec
DELETE FROM projects
WHERE user_id = $1
`

func (q *Queries) DeleteProjectsByUserID(ctx context.Context, userID string) error {
	_, err := q.db.Exec(ctx, deleteProjectsByUserID, userID)
	return err
}

const getActiveProjectsByUserID = `-- name: GetActiveProjectsByUserID :many
SELECT id, name, user_id, repo_id, repo_name, repo_full_name, repo_url, repo_branch, status, env_variables, deployment_status, domain, port, created_at, updated_at
FROM projects
WHERE user_id = $1 AND status = 'active'
ORDER BY created_at DESC
`

func (q *Queries) GetActiveProjectsByUserID(ctx context.Context, userID string) ([]Project, error) {
	rows, err := q.db.Query(ctx, getActiveProjectsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.RepoID,
			&i.RepoName,
			&i.RepoFullName,
			&i.RepoUrl,
			&i.RepoBranch,
			&i.Status,
			&i.EnvVariables,
			&i.DeploymentStatus,
			&i.Domain,
			&i.Port,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectByID = `-- name: GetProjectByID :one
SELECT id, name, user_id, repo_id, repo_name, repo_full_name, repo_url, repo_branch, status, env_variables, deployment_status, domain, port, created_at, updated_at
FROM projects
WHERE id = $1
`

func (q *Queries) GetProjectByID(ctx context.Context, id string) (Project, error) {
	row := q.db.QueryRow(ctx, getProjectByID, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.RepoID,
		&i.RepoName,
		&i.RepoFullName,
		&i.RepoUrl,
		&i.RepoBranch,
		&i.Status,
		&i.EnvVariables,
		&i.DeploymentStatus,
		&i.Domain,
		&i.Port,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectByUserIDAndName = `-- name: GetProjectByUserIDAndName :one
SELECT id, name, user_id, repo_id, repo_name, repo_full_name, repo_url, repo_branch, status, env_variables, deployment_status, domain, port, created_at, updated_at
FROM projects
WHERE user_id = $1 AND name = $2
`

type GetProjectByUserIDAndNameParams struct {
	UserID string `json:"user_id"`
	Name   string `json:"name"`
}

func (q *Queries) GetProjectByUserIDAndName(ctx context.Context, arg GetProjectByUserIDAndNameParams) (Project, error) {
	row := q.db.QueryRow(ctx, getProjectByUserIDAndName, arg.UserID, arg.Name)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.RepoID,
		&i.RepoName,
		&i.RepoFullName,
		&i.RepoUrl,
		&i.RepoBranch,
		&i.Status,
		&i.EnvVariables,
		&i.DeploymentStatus,
		&i.Domain,
		&i.Port,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectsByRepoID = `-- name: GetProjectsByRepoID :many
SELECT id, name, user_id, repo_id, repo_name, repo_full_name, repo_url, repo_branch, status, env_variables, deployment_status, domain, port, created_at, updated_at
FROM projects
WHERE repo_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetProjectsByRepoID(ctx context.Context, repoID int64) ([]Project, error) {
	rows, err := q.db.Query(ctx, getProjectsByRepoID, repoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.RepoID,
			&i.RepoName,
			&i.RepoFullName,
			&i.RepoUrl,
			&i.RepoBranch,
			&i.Status,
			&i.EnvVariables,
			&i.DeploymentStatus,
			&i.Domain,
			&i.Port,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectsByUserID = `-- name: GetProjectsByUserID :many
SELECT id, name, user_id, repo_id, repo_name, repo_full_name, repo_url, repo_branch, status, env_variables, deployment_status, domain, port, created_at, updated_at
FROM projects
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetProjectsByUserID(ctx context.Context, userID string) ([]Project, error) {
	rows, err := q.db.Query(ctx, getProjectsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.RepoID,
			&i.RepoName,
			&i.RepoFullName,
			&i.RepoUrl,
			&i.RepoBranch,
			&i.Status,
			&i.EnvVariables,
			&i.DeploymentStatus,
			&i.Domain,
			&i.Port,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectsByUserIDAndStatus = `-- name: GetProjectsByUserIDAndStatus :many
SELECT id, name, user_id, repo_id, repo_name, repo_full_name, repo_url, repo_branch, status, env_variables, deployment_status, domain, port, created_at, updated_at
FROM projects
WHERE user_id = $1 AND status = $2
ORDER BY created_at DESC
`

type GetProjectsByUserIDAndStatusParams struct {
	UserID string `json:"user_id"`
	Status string `json:"status"`
}

func (q *Queries) GetProjectsByUserIDAndStatus(ctx context.Context, arg GetProjectsByUserIDAndStatusParams) ([]Project, error) {
	rows, err := q.db.Query(ctx, getProjectsByUserIDAndStatus, arg.UserID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.RepoID,
			&i.RepoName,
			&i.RepoFullName,
			&i.RepoUrl,
			&i.RepoBranch,
			&i.Status,
			&i.EnvVariables,
			&i.DeploymentStatus,
			&i.Domain,
			&i.Port,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsedPorts = `-- name: GetUsedPorts :many
SELECT port FROM projects WHERE port IS NOT NULL ORDER BY port ASC
`

func (q *Queries) GetUsedPorts(ctx context.Context) ([]pgtype.Int4, error) {
	rows, err := q.db.Query(ctx, getUsedPorts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.Int4{}
	for rows.Next() {
		var port pgtype.Int4
		if err := rows.Scan(&port); err != nil {
			return nil, err
		}
		items = append(items, port)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjects = `-- name: ListProjects :many
SELECT id, name, user_id, repo_id, repo_name, repo_full_name, repo_url, repo_branch, status, env_variables, deployment_status, domain, port, created_at, updated_at
FROM projects
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListProjectsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListProjects(ctx context.Context, arg ListProjectsParams) ([]Project, error) {
	rows, err := q.db.Query(ctx, listProjects, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.RepoID,
			&i.RepoName,
			&i.RepoFullName,
			&i.RepoUrl,
			&i.RepoBranch,
			&i.Status,
			&i.EnvVariables,
			&i.DeploymentStatus,
			&i.Domain,
			&i.Port,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectsByStatus = `-- name: ListProjectsByStatus :many
SELECT id, name, user_id, repo_id, repo_name, repo_full_name, repo_url, repo_branch, status, env_variables, deployment_status, domain, port, created_at, updated_at
FROM projects
WHERE status = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListProjectsByStatusParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListProjectsByStatus(ctx context.Context, arg ListProjectsByStatusParams) ([]Project, error) {
	rows, err := q.db.Query(ctx, listProjectsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.RepoID,
			&i.RepoName,
			&i.RepoFullName,
			&i.RepoUrl,
			&i.RepoBranch,
			&i.Status,
			&i.EnvVariables,
			&i.DeploymentStatus,
			&i.Domain,
			&i.Port,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const projectExistsByID = `-- name: ProjectExistsByID :one
SELECT EXISTS(SELECT 1 FROM projects WHERE id = $1)
`

func (q *Queries) ProjectExistsByID(ctx context.Context, id string) (bool, error) {
	row := q.db.QueryRow(ctx, projectExistsByID, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const projectExistsByUserIDAndName = `-- name: ProjectExistsByUserIDAndName :one
SELECT EXISTS(SELECT 1 FROM projects WHERE user_id = $1 AND name = $2)
`

type ProjectExistsByUserIDAndNameParams struct {
	UserID string `json:"user_id"`
	Name   string `json:"name"`
}

func (q *Queries) ProjectExistsByUserIDAndName(ctx context.Context, arg ProjectExistsByUserIDAndNameParams) (bool, error) {
	row := q.db.QueryRow(ctx, projectExistsByUserIDAndName, arg.UserID, arg.Name)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const searchProjects = `-- name: SearchProjects :many
SELECT id, name, user_id, repo_id, repo_name, repo_full_name, repo_url, repo_branch, status, env_variables, deployment_status, domain, port, created_at, updated_at
FROM projects
WHERE name ILIKE '%' || $1 || '%' 
   OR repo_name ILIKE '%' || $1 || '%'
   OR repo_full_name ILIKE '%' || $1 || '%'
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type SearchProjectsParams struct {
	Column1 pgtype.Text `json:"column_1"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) SearchProjects(ctx context.Context, arg SearchProjectsParams) ([]Project, error) {
	rows, err := q.db.Query(ctx, searchProjects, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.RepoID,
			&i.RepoName,
			&i.RepoFullName,
			&i.RepoUrl,
			&i.RepoBranch,
			&i.Status,
			&i.EnvVariables,
			&i.DeploymentStatus,
			&i.Domain,
			&i.Port,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProjectsByUserID = `-- name: SearchProjectsByUserID :many
SELECT id, name, user_id, repo_id, repo_name, repo_full_name, repo_url, repo_branch, status, env_variables, deployment_status, domain, port, created_at, updated_at
FROM projects
WHERE user_id = $1 AND (
    name ILIKE '%' || $2 || '%' 
    OR repo_name ILIKE '%' || $2 || '%'
    OR repo_full_name ILIKE '%' || $2 || '%'
)
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type SearchProjectsByUserIDParams struct {
	UserID  string      `json:"user_id"`
	Column2 pgtype.Text `json:"column_2"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) SearchProjectsByUserID(ctx context.Context, arg SearchProjectsByUserIDParams) ([]Project, error) {
	rows, err := q.db.Query(ctx, searchProjectsByUserID,
		arg.UserID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.RepoID,
			&i.RepoName,
			&i.RepoFullName,
			&i.RepoUrl,
			&i.RepoBranch,
			&i.Status,
			&i.EnvVariables,
			&i.DeploymentStatus,
			&i.Domain,
			&i.Port,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects
SET name = $2, repo_branch = $3, status = $4, domain = $5, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, user_id, repo_id, repo_name, repo_full_name, repo_url, repo_branch, status, env_variables, deployment_status, domain, port, created_at, updated_at
`

type UpdateProjectParams struct {
	ID         string      `json:"id"`
	Name       string      `json:"name"`
	RepoBranch string      `json:"repo_branch"`
	Status     string      `json:"status"`
	Domain     pgtype.Text `json:"domain"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, updateProject,
		arg.ID,
		arg.Name,
		arg.RepoBranch,
		arg.Status,
		arg.Domain,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.RepoID,
		&i.RepoName,
		&i.RepoFullName,
		&i.RepoUrl,
		&i.RepoBranch,
		&i.Status,
		&i.EnvVariables,
		&i.DeploymentStatus,
		&i.Domain,
		&i.Port,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProjectBranch = `-- name: UpdateProjectBranch :one
UPDATE projects
SET repo_branch = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, user_id, repo_id, repo_name, repo_full_name, repo_url, repo_branch, status, env_variables, deployment_status, domain, port, created_at, updated_at
`

type UpdateProjectBranchParams struct {
	ID         string `json:"id"`
	RepoBranch string `json:"repo_branch"`
}

func (q *Queries) UpdateProjectBranch(ctx context.Context, arg UpdateProjectBranchParams) (Project, error) {
	row := q.db.QueryRow(ctx, updateProjectBranch, arg.ID, arg.RepoBranch)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.RepoID,
		&i.RepoName,
		&i.RepoFullName,
		&i.RepoUrl,
		&i.RepoBranch,
		&i.Status,
		&i.EnvVariables,
		&i.DeploymentStatus,
		&i.Domain,
		&i.Port,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProjectDeploymentStatus = `-- name: UpdateProjectDeploymentStatus :one
UPDATE projects
SET deployment_status = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, user_id, repo_id, repo_name, repo_full_name, repo_url, repo_branch, status, env_variables, deployment_status, domain, port, created_at, updated_at
`

type UpdateProjectDeploymentStatusParams struct {
	ID               string `json:"id"`
	DeploymentStatus string `json:"deployment_status"`
}

func (q *Queries) UpdateProjectDeploymentStatus(ctx context.Context, arg UpdateProjectDeploymentStatusParams) (Project, error) {
	row := q.db.QueryRow(ctx, updateProjectDeploymentStatus, arg.ID, arg.DeploymentStatus)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.RepoID,
		&i.RepoName,
		&i.RepoFullName,
		&i.RepoUrl,
		&i.RepoBranch,
		&i.Status,
		&i.EnvVariables,
		&i.DeploymentStatus,
		&i.Domain,
		&i.Port,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProjectPort = `-- name: UpdateProjectPort :exec
UPDATE projects
SET port = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateProjectPortParams struct {
	ID   string      `json:"id"`
	Port pgtype.Int4 `json:"port"`
}

func (q *Queries) UpdateProjectPort(ctx context.Context, arg UpdateProjectPortParams) error {
	_, err := q.db.Exec(ctx, updateProjectPort, arg.ID, arg.Port)
	return err
}

const updateProjectStatus = `-- name: UpdateProjectStatus :one
UPDATE projects
SET status = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, user_id, repo_id, repo_name, repo_full_name, repo_url, repo_branch, status, env_variables, deployment_status, domain, port, created_at, updated_at
`

type UpdateProjectStatusParams struct {
	ID     string `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) UpdateProjectStatus(ctx context.Context, arg UpdateProjectStatusParams) (Project, error) {
	row := q.db.QueryRow(ctx, updateProjectStatus, arg.ID, arg.Status)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.RepoID,
		&i.RepoName,
		&i.RepoFullName,
		&i.RepoUrl,
		&i.RepoBranch,
		&i.Status,
		&i.EnvVariables,
		&i.DeploymentStatus,
		&i.Domain,
		&i.Port,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
