// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: accounts.sql

package generated

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const accountExistsByGithubID = `-- name: AccountExistsByGithubID :one
SELECT EXISTS(SELECT 1 FROM accounts WHERE github_id = $1)
`

func (q *Queries) AccountExistsByGithubID(ctx context.Context, githubID int64) (bool, error) {
	row := q.db.QueryRow(ctx, accountExistsByGithubID, githubID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const accountExistsByGithubUsername = `-- name: AccountExistsByGithubUsername :one
SELECT EXISTS(SELECT 1 FROM accounts WHERE github_username = $1)
`

func (q *Queries) AccountExistsByGithubUsername(ctx context.Context, githubUsername string) (bool, error) {
	row := q.db.QueryRow(ctx, accountExistsByGithubUsername, githubUsername)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const accountExistsByUserIDAndGithubID = `-- name: AccountExistsByUserIDAndGithubID :one
SELECT EXISTS(SELECT 1 FROM accounts WHERE user_id = $1 AND github_id = $2)
`

type AccountExistsByUserIDAndGithubIDParams struct {
	UserID   string `json:"user_id"`
	GithubID int64  `json:"github_id"`
}

func (q *Queries) AccountExistsByUserIDAndGithubID(ctx context.Context, arg AccountExistsByUserIDAndGithubIDParams) (bool, error) {
	row := q.db.QueryRow(ctx, accountExistsByUserIDAndGithubID, arg.UserID, arg.GithubID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const accountExistsForUser = `-- name: AccountExistsForUser :one
SELECT EXISTS(SELECT 1 FROM accounts WHERE user_id = $1 AND github_id = $2)
`

type AccountExistsForUserParams struct {
	UserID   string `json:"user_id"`
	GithubID int64  `json:"github_id"`
}

func (q *Queries) AccountExistsForUser(ctx context.Context, arg AccountExistsForUserParams) (bool, error) {
	row := q.db.QueryRow(ctx, accountExistsForUser, arg.UserID, arg.GithubID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countAccounts = `-- name: CountAccounts :one
SELECT COUNT(*) FROM accounts
`

func (q *Queries) CountAccounts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAccounts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAccountsByUserID = `-- name: CountAccountsByUserID :one
SELECT COUNT(*) FROM accounts WHERE user_id = $1
`

func (q *Queries) CountAccountsByUserID(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countAccountsByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAccount = `-- name: CreateAccount :one
INSERT INTO accounts (user_id, github_username, github_id, avatar_url, access_token)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, github_username, github_id, avatar_url, created_at, updated_at
`

type CreateAccountParams struct {
	UserID         string      `json:"user_id"`
	GithubUsername string      `json:"github_username"`
	GithubID       int64       `json:"github_id"`
	AvatarUrl      pgtype.Text `json:"avatar_url"`
	AccessToken    string      `json:"access_token"`
}

type CreateAccountRow struct {
	ID             string      `json:"id"`
	UserID         string      `json:"user_id"`
	GithubUsername string      `json:"github_username"`
	GithubID       int64       `json:"github_id"`
	AvatarUrl      pgtype.Text `json:"avatar_url"`
	CreatedAt      time.Time   `json:"created_at"`
	UpdatedAt      time.Time   `json:"updated_at"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (CreateAccountRow, error) {
	row := q.db.QueryRow(ctx, createAccount,
		arg.UserID,
		arg.GithubUsername,
		arg.GithubID,
		arg.AvatarUrl,
		arg.AccessToken,
	)
	var i CreateAccountRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GithubUsername,
		&i.GithubID,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAccount = `-- name: DeleteAccount :exec
DELETE FROM accounts
WHERE id = $1
`

func (q *Queries) DeleteAccount(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteAccount, id)
	return err
}

const deleteAccountByGithubID = `-- name: DeleteAccountByGithubID :exec
DELETE FROM accounts
WHERE github_id = $1
`

func (q *Queries) DeleteAccountByGithubID(ctx context.Context, githubID int64) error {
	_, err := q.db.Exec(ctx, deleteAccountByGithubID, githubID)
	return err
}

const deleteAccountsByUserID = `-- name: DeleteAccountsByUserID :exec
DELETE FROM accounts
WHERE user_id = $1
`

func (q *Queries) DeleteAccountsByUserID(ctx context.Context, userID string) error {
	_, err := q.db.Exec(ctx, deleteAccountsByUserID, userID)
	return err
}

const getAccountByGithubID = `-- name: GetAccountByGithubID :one
SELECT id, user_id, github_username, github_id, avatar_url, access_token, created_at, updated_at
FROM accounts
WHERE github_id = $1
`

func (q *Queries) GetAccountByGithubID(ctx context.Context, githubID int64) (Account, error) {
	row := q.db.QueryRow(ctx, getAccountByGithubID, githubID)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GithubUsername,
		&i.GithubID,
		&i.AvatarUrl,
		&i.AccessToken,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountByGithubUsername = `-- name: GetAccountByGithubUsername :one
SELECT id, user_id, github_username, github_id, avatar_url, access_token, created_at, updated_at
FROM accounts
WHERE github_username = $1
`

func (q *Queries) GetAccountByGithubUsername(ctx context.Context, githubUsername string) (Account, error) {
	row := q.db.QueryRow(ctx, getAccountByGithubUsername, githubUsername)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GithubUsername,
		&i.GithubID,
		&i.AvatarUrl,
		&i.AccessToken,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountByID = `-- name: GetAccountByID :one
SELECT id, user_id, github_username, github_id, avatar_url, access_token, created_at, updated_at
FROM accounts
WHERE id = $1
`

func (q *Queries) GetAccountByID(ctx context.Context, id string) (Account, error) {
	row := q.db.QueryRow(ctx, getAccountByID, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GithubUsername,
		&i.GithubID,
		&i.AvatarUrl,
		&i.AccessToken,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountWithUser = `-- name: GetAccountWithUser :one
SELECT 
    a.id,
    a.user_id,
    a.github_username,
    a.github_id,
    a.avatar_url,
    a.access_token,
    a.created_at,
    a.updated_at,
    u.username,
    u.email
FROM accounts a
JOIN users u ON a.user_id = u.id
WHERE a.id = $1
`

type GetAccountWithUserRow struct {
	ID             string      `json:"id"`
	UserID         string      `json:"user_id"`
	GithubUsername string      `json:"github_username"`
	GithubID       int64       `json:"github_id"`
	AvatarUrl      pgtype.Text `json:"avatar_url"`
	AccessToken    string      `json:"access_token"`
	CreatedAt      time.Time   `json:"created_at"`
	UpdatedAt      time.Time   `json:"updated_at"`
	Username       string      `json:"username"`
	Email          string      `json:"email"`
}

func (q *Queries) GetAccountWithUser(ctx context.Context, id string) (GetAccountWithUserRow, error) {
	row := q.db.QueryRow(ctx, getAccountWithUser, id)
	var i GetAccountWithUserRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GithubUsername,
		&i.GithubID,
		&i.AvatarUrl,
		&i.AccessToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
		&i.Email,
	)
	return i, err
}

const getAccountsByUserID = `-- name: GetAccountsByUserID :many
SELECT id, user_id, github_username, github_id, avatar_url, created_at, updated_at
FROM accounts
WHERE user_id = $1
ORDER BY created_at DESC
`

type GetAccountsByUserIDRow struct {
	ID             string      `json:"id"`
	UserID         string      `json:"user_id"`
	GithubUsername string      `json:"github_username"`
	GithubID       int64       `json:"github_id"`
	AvatarUrl      pgtype.Text `json:"avatar_url"`
	CreatedAt      time.Time   `json:"created_at"`
	UpdatedAt      time.Time   `json:"updated_at"`
}

func (q *Queries) GetAccountsByUserID(ctx context.Context, userID string) ([]GetAccountsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getAccountsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAccountsByUserIDRow{}
	for rows.Next() {
		var i GetAccountsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GithubUsername,
			&i.GithubID,
			&i.AvatarUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountsByUserIDWithTokens = `-- name: GetAccountsByUserIDWithTokens :many
SELECT id, user_id, github_username, github_id, avatar_url, access_token, created_at, updated_at
FROM accounts
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetAccountsByUserIDWithTokens(ctx context.Context, userID string) ([]Account, error) {
	rows, err := q.db.Query(ctx, getAccountsByUserIDWithTokens, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Account{}
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GithubUsername,
			&i.GithubID,
			&i.AvatarUrl,
			&i.AccessToken,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccounts = `-- name: ListAccounts :many
SELECT id, user_id, github_username, github_id, avatar_url, created_at, updated_at
FROM accounts
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListAccountsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListAccountsRow struct {
	ID             string      `json:"id"`
	UserID         string      `json:"user_id"`
	GithubUsername string      `json:"github_username"`
	GithubID       int64       `json:"github_id"`
	AvatarUrl      pgtype.Text `json:"avatar_url"`
	CreatedAt      time.Time   `json:"created_at"`
	UpdatedAt      time.Time   `json:"updated_at"`
}

func (q *Queries) ListAccounts(ctx context.Context, arg ListAccountsParams) ([]ListAccountsRow, error) {
	rows, err := q.db.Query(ctx, listAccounts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAccountsRow{}
	for rows.Next() {
		var i ListAccountsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GithubUsername,
			&i.GithubID,
			&i.AvatarUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAccounts = `-- name: SearchAccounts :many
SELECT id, user_id, github_username, github_id, avatar_url, created_at, updated_at
FROM accounts
WHERE github_username ILIKE '%' || $1 || '%'
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type SearchAccountsParams struct {
	Column1 pgtype.Text `json:"column_1"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type SearchAccountsRow struct {
	ID             string      `json:"id"`
	UserID         string      `json:"user_id"`
	GithubUsername string      `json:"github_username"`
	GithubID       int64       `json:"github_id"`
	AvatarUrl      pgtype.Text `json:"avatar_url"`
	CreatedAt      time.Time   `json:"created_at"`
	UpdatedAt      time.Time   `json:"updated_at"`
}

func (q *Queries) SearchAccounts(ctx context.Context, arg SearchAccountsParams) ([]SearchAccountsRow, error) {
	rows, err := q.db.Query(ctx, searchAccounts, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchAccountsRow{}
	for rows.Next() {
		var i SearchAccountsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GithubUsername,
			&i.GithubID,
			&i.AvatarUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAccountsByUserID = `-- name: SearchAccountsByUserID :many
SELECT id, user_id, github_username, github_id, avatar_url, created_at, updated_at
FROM accounts
WHERE user_id = $1 AND github_username ILIKE '%' || $2 || '%'
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type SearchAccountsByUserIDParams struct {
	UserID  string      `json:"user_id"`
	Column2 pgtype.Text `json:"column_2"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type SearchAccountsByUserIDRow struct {
	ID             string      `json:"id"`
	UserID         string      `json:"user_id"`
	GithubUsername string      `json:"github_username"`
	GithubID       int64       `json:"github_id"`
	AvatarUrl      pgtype.Text `json:"avatar_url"`
	CreatedAt      time.Time   `json:"created_at"`
	UpdatedAt      time.Time   `json:"updated_at"`
}

func (q *Queries) SearchAccountsByUserID(ctx context.Context, arg SearchAccountsByUserIDParams) ([]SearchAccountsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, searchAccountsByUserID,
		arg.UserID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchAccountsByUserIDRow{}
	for rows.Next() {
		var i SearchAccountsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GithubUsername,
			&i.GithubID,
			&i.AvatarUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccount = `-- name: UpdateAccount :one
UPDATE accounts
SET github_username = $2, avatar_url = $3, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, user_id, github_username, github_id, avatar_url, created_at, updated_at
`

type UpdateAccountParams struct {
	ID             string      `json:"id"`
	GithubUsername string      `json:"github_username"`
	AvatarUrl      pgtype.Text `json:"avatar_url"`
}

type UpdateAccountRow struct {
	ID             string      `json:"id"`
	UserID         string      `json:"user_id"`
	GithubUsername string      `json:"github_username"`
	GithubID       int64       `json:"github_id"`
	AvatarUrl      pgtype.Text `json:"avatar_url"`
	CreatedAt      time.Time   `json:"created_at"`
	UpdatedAt      time.Time   `json:"updated_at"`
}

func (q *Queries) UpdateAccount(ctx context.Context, arg UpdateAccountParams) (UpdateAccountRow, error) {
	row := q.db.QueryRow(ctx, updateAccount, arg.ID, arg.GithubUsername, arg.AvatarUrl)
	var i UpdateAccountRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GithubUsername,
		&i.GithubID,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAccountByGithubID = `-- name: UpdateAccountByGithubID :one
UPDATE accounts
SET github_username = $2, avatar_url = $3, access_token = $4, updated_at = CURRENT_TIMESTAMP
WHERE github_id = $1
RETURNING id, user_id, github_username, github_id, avatar_url, created_at, updated_at
`

type UpdateAccountByGithubIDParams struct {
	GithubID       int64       `json:"github_id"`
	GithubUsername string      `json:"github_username"`
	AvatarUrl      pgtype.Text `json:"avatar_url"`
	AccessToken    string      `json:"access_token"`
}

type UpdateAccountByGithubIDRow struct {
	ID             string      `json:"id"`
	UserID         string      `json:"user_id"`
	GithubUsername string      `json:"github_username"`
	GithubID       int64       `json:"github_id"`
	AvatarUrl      pgtype.Text `json:"avatar_url"`
	CreatedAt      time.Time   `json:"created_at"`
	UpdatedAt      time.Time   `json:"updated_at"`
}

func (q *Queries) UpdateAccountByGithubID(ctx context.Context, arg UpdateAccountByGithubIDParams) (UpdateAccountByGithubIDRow, error) {
	row := q.db.QueryRow(ctx, updateAccountByGithubID,
		arg.GithubID,
		arg.GithubUsername,
		arg.AvatarUrl,
		arg.AccessToken,
	)
	var i UpdateAccountByGithubIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GithubUsername,
		&i.GithubID,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAccountToken = `-- name: UpdateAccountToken :one
UPDATE accounts
SET access_token = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, user_id, github_username, github_id, avatar_url, created_at, updated_at
`

type UpdateAccountTokenParams struct {
	ID          string `json:"id"`
	AccessToken string `json:"access_token"`
}

type UpdateAccountTokenRow struct {
	ID             string      `json:"id"`
	UserID         string      `json:"user_id"`
	GithubUsername string      `json:"github_username"`
	GithubID       int64       `json:"github_id"`
	AvatarUrl      pgtype.Text `json:"avatar_url"`
	CreatedAt      time.Time   `json:"created_at"`
	UpdatedAt      time.Time   `json:"updated_at"`
}

func (q *Queries) UpdateAccountToken(ctx context.Context, arg UpdateAccountTokenParams) (UpdateAccountTokenRow, error) {
	row := q.db.QueryRow(ctx, updateAccountToken, arg.ID, arg.AccessToken)
	var i UpdateAccountTokenRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GithubUsername,
		&i.GithubID,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
